<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Brain Multi-UV Visualization</title>
    
    <!-- é¦–å…ˆå¼•å…¥ Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- å¼•å…¥ OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    
    <!-- æ§åˆ¶é¢æ¿æ ·å¼ -->
    <style>
        .control-panel {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            z-index: 1000;
            max-width: 300px;
            backdrop-filter: blur(10px);
        }
        
        .uv-layer {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }
        
        .layer-controls {
            display: flex;
            gap: 10px;
            margin-top: 5px;
        }
        
        .layer-controls button {
            flex: 1;
            padding: 5px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            border-radius: 3px;
            cursor: pointer;
        }
        
        .layer-controls button:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .color-ramp {
            height: 20px;
            width: 100%;
            background: linear-gradient(to right, blue, cyan, green, yellow, red);
            margin: 5px 0;
            border-radius: 3px;
        }
        
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
        }
        
        canvas {
            display: block;
        }
        
        input[type="range"] {
            width: 100%;
        }
        
        select {
            width: 100%;
            padding: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }
        
        button {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
        }
        
        button:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        h3 {
            margin-top: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
    </style>
</head>
<body>
    <canvas id="background"></canvas>
    
    <!-- æ§åˆ¶é¢æ¿ -->
    <div class="control-panel">
        <h3>ğŸ§  å¯è§†åŒ–</h3>
        <div id="uv-layers-container"></div>
        <div>
            <button id="add-uv-layer" style="width:100%; padding:8px; margin-top:10px;">
                â• æ·»åŠ UVå±‚
            </button>
        </div>
        <div style="margin-top:15px; border-top:1px solid rgba(255,255,255,0.2); padding-top:10px;">
            <label style="display:block; margin-bottom:5px;">æ··åˆæ¨¡å¼:</label>
            <select id="blend-mode">
                <option value="additive">å åŠ </option>
                <option value="multiply">ç›¸ä¹˜</option>
                <option value="overlay">è¦†ç›–</option>
                <option value="difference">å·®å¼‚</option>
            </select>
        </div>
        <div style="margin-top:10px;">
            <label style="display:block; margin-bottom:5px;">é€æ˜åº¦: <span id="opacity-value">0.5</span></label>
            <input type="range" id="global-opacity" min="0" max="1" step="0.1" value="0.5">
        </div>
    </div>
    
    <!-- JavaScriptä»£ç  - æ³¨æ„ï¼šè¿™é‡Œä¸ä½¿ç”¨æ¨¡å—ï¼Œç›´æ¥å†™ä»£ç  -->
    <script>
        // ç­‰å¾…é¡µé¢å®Œå…¨åŠ è½½
        document.addEventListener('DOMContentLoaded', function() {
            // åˆå§‹åŒ–Three.jsåœºæ™¯
            let scene, camera, renderer, controls;
            let brainMesh;
            let uvLayers = [];
            let currentLayerId = 0;
            
            // åˆå§‹åŒ–åœºæ™¯
            function init() {
                console.log("åˆå§‹åŒ–Three.jsåœºæ™¯ï¼ŒTHREEå¯¹è±¡:", typeof THREE);
                
                // åˆ›å»ºåœºæ™¯
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x0a0a0a);
                
                // åˆ›å»ºç›¸æœº
                camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                camera.position.z = 5;
                
                // åˆ›å»ºæ¸²æŸ“å™¨
                const canvas = document.getElementById('background');
                renderer = new THREE.WebGLRenderer({
                    canvas: canvas,
                    antialias: true
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                
                // æ·»åŠ å…‰æº
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(1, 1, 1);
                scene.add(directionalLight);
                
                // åˆ›å»ºæ¨¡æ‹Ÿçš„è„‘éƒ¨æ¨¡å‹ï¼ˆä¸€ä¸ªçƒä½“ï¼‰
                const geometry = new THREE.SphereGeometry(2, 64, 64);
                
                // åˆ›å»ºåŸºæœ¬æè´¨
                const material = new THREE.MeshPhongMaterial({
                    color: 0x4444ff,
                    shininess: 30,
                    transparent: true,
                    opacity: 0.7
                });
                
                brainMesh = new THREE.Mesh(geometry, material);
                scene.add(brainMesh);
                
                // æ·»åŠ ç½‘æ ¼è¾…åŠ©çº¿
                const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
                scene.add(gridHelper);
                
                // æ·»åŠ åæ ‡è½´è¾…åŠ©çº¿
                const axesHelper = new THREE.AxesHelper(5);
                scene.add(axesHelper);
                
                // æ·»åŠ è½¨é“æ§åˆ¶å™¨
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                
                // çª—å£å¤§å°è°ƒæ•´
                window.addEventListener('resize', onWindowResize);
                
                // åˆå§‹åŒ–UI
                initUI();
                
                // å¼€å§‹åŠ¨ç”»
                animate();
            }
            
            // çª—å£å¤§å°è°ƒæ•´
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            // åˆå§‹åŒ–UI
            function initUI() {
                // æ·»åŠ UVå±‚æŒ‰é’®
                document.getElementById('add-uv-layer').addEventListener('click', addUVLayer);
                
                // å…¨å±€é€æ˜åº¦æ§åˆ¶
                const opacitySlider = document.getElementById('global-opacity');
                const opacityValue = document.getElementById('opacity-value');
                
                opacitySlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    opacityValue.textContent = value.toFixed(1);
                    if (brainMesh && brainMesh.material) {
                        brainMesh.material.opacity = value;
                    }
                });
                
                // æ··åˆæ¨¡å¼æ§åˆ¶
                document.getElementById('blend-mode').addEventListener('change', (e) => {
                    // è¿™é‡Œå¯ä»¥æ·»åŠ æ··åˆæ¨¡å¼çš„å®ç°
                    console.log('æ··åˆæ¨¡å¼æ”¹ä¸º:', e.target.value);
                });
                
                // æ·»åŠ åˆå§‹çš„UVå±‚
                addUVLayer();
                addUVLayer();
            }
            
            // æ·»åŠ UVå±‚
            function addUVLayer() {
                currentLayerId++;
                const layer = {
                    id: currentLayerId,
                    name: `UVå±‚ ${currentLayerId}`,
                    visible: true,
                    opacity: 0.5,
                    colorRamp: 'default'
                };
                
                uvLayers.push(layer);
                updateUVLayersUI();
            }
            
            // ç§»é™¤UVå±‚
            function removeUVLayer(id) {
                uvLayers = uvLayers.filter(layer => layer.id !== id);
                updateUVLayersUI();
            }
            
            // æ›´æ–°UVå±‚UI
            function updateUVLayersUI() {
                const container = document.getElementById('uv-layers-container');
                container.innerHTML = '';
                
                uvLayers.forEach(layer => {
                    const layerDiv = document.createElement('div');
                    layerDiv.className = 'uv-layer';
                    layerDiv.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <strong>${layer.name}</strong>
                            <input type="checkbox" ${layer.visible ? 'checked' : ''} 
                                   onchange="window.toggleLayerVisibility(${layer.id}, this.checked)"
                                   style="transform: scale(1.2);">
                        </div>
                        <div style="margin: 8px 0;">
                            <label>ä¸é€æ˜åº¦: ${layer.opacity.toFixed(1)}</label>
                            <input type="range" min="0" max="1" step="0.1" value="${layer.opacity}"
                                   oninput="window.updateLayerOpacity(${layer.id}, this.value)">
                        </div>
                        <div class="color-ramp"></div>
                        <div class="layer-controls">
                            <button onclick="window.moveLayerUp(${layer.id})">â¬† ä¸Šç§»</button>
                            <button onclick="window.moveLayerDown(${layer.id})">â¬‡ ä¸‹ç§»</button>
                            <button onclick="window.removeUVLayer(${layer.id})" style="background: rgba(255,50,50,0.3);">ğŸ—‘ åˆ é™¤</button>
                        </div>
                    `;
                    container.appendChild(layerDiv);
                });
            }
            
            // æš´éœ²å…¨å±€å‡½æ•°ä¾›æŒ‰é’®è°ƒç”¨
            window.toggleLayerVisibility = function(id, visible) {
                const layer = uvLayers.find(l => l.id === id);
                if (layer) {
                    layer.visible = visible;
                    console.log(`å±‚ ${id} å¯è§æ€§: ${visible}`);
                }
            };
            
            window.updateLayerOpacity = function(id, opacity) {
                const layer = uvLayers.find(l => l.id === id);
                if (layer) {
                    layer.opacity = parseFloat(opacity);
                    console.log(`å±‚ ${id} ä¸é€æ˜åº¦: ${opacity}`);
                    updateUVLayersUI();
                }
            };
            
            window.moveLayerUp = function(id) {
                const index = uvLayers.findIndex(l => l.id === id);
                if (index > 0) {
                    [uvLayers[index], uvLayers[index - 1]] = [uvLayers[index - 1], uvLayers[index]];
                    updateUVLayersUI();
                    console.log(`å±‚ ${id} ä¸Šç§»`);
                }
            };
            
            window.moveLayerDown = function(id) {
                const index = uvLayers.findIndex(l => l.id === id);
                if (index < uvLayers.length - 1) {
                    [uvLayers[index], uvLayers[index + 1]] = [uvLayers[index + 1], uvLayers[index]];
                    updateUVLayersUI();
                    console.log(`å±‚ ${id} ä¸‹ç§»`);
                }
            };
            
            window.removeUVLayer = function(id) {
                uvLayers = uvLayers.filter(layer => layer.id !== id);
                updateUVLayersUI();
                console.log(`åˆ é™¤å±‚ ${id}`);
            };
            
            // åŠ¨ç”»å¾ªç¯
            function animate() {
                requestAnimationFrame(animate);
                
                if (brainMesh) {
                    brainMesh.rotation.y += 0.005;
                }
                
                if (controls) {
                    controls.update();
                }
                
                renderer.render(scene, camera);
            }
            
            // æ£€æŸ¥Three.jsæ˜¯å¦å·²åŠ è½½
            if (typeof THREE === 'undefined') {
                console.error('THREE is not defined. Make sure Three.js is loaded correctly.');
                // å»¶è¿Ÿåˆå§‹åŒ–ï¼Œç­‰å¾…Three.jsåŠ è½½
                setTimeout(init, 100);
            } else {
                init();
            }
        });
    </script>
</body>
</html>